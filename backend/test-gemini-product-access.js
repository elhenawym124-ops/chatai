const { PrismaClient } = require('@prisma/client');

async function testGeminiProductAccess() {
  const prisma = new PrismaClient();
  
  try {
    console.log('๐ Testing Gemini Access to Product Data...\n');
    
    // Test 1: Check if handleSpecificProductQuestion works
    console.log('๐ Test 1: Testing handleSpecificProductQuestion function...');
    
    const testQuestions = [
      'ูุงู ุณุนุฑ ุงูููุชุดู ุงููุงููุ',
      'ุนูุฏูู ุทูู ุฃุฏูุงุช ุงููุทุจุฎ ูุชููุฑุ',
      'ุฅูู ููุงุตูุงุช ุงููุงุชู ุงูุฐููุ',
      'ุนุงูุฒ ุฃุนุฑู ุชูุงุตูู ุงููููุต ุงููุทูู'
    ];
    
    const companyId = 'cmd5c0c9y0000ymzdd7wtv7ib';
    
    for (const question of testQuestions) {
      console.log(`\nโ Question: "${question}"`);
      
      try {
        const specificAnswer = await handleSpecificProductQuestion(question, companyId);
        
        if (specificAnswer) {
          console.log(`โ Found specific answer:`);
          console.log(`๐ Type: ${specificAnswer.questionType}`);
          console.log(`๐ฌ Answer: "${specificAnswer.answer}"`);
          if (specificAnswer.product) {
            console.log(`๐๏ธ Product Details:`);
            console.log(`   ๐ Name: ${specificAnswer.product.name}`);
            console.log(`   ๐ฐ Price: ${specificAnswer.product.price} ุฌููู`);
            console.log(`   ๐ฆ Stock: ${specificAnswer.product.stock} ูุทุนุฉ`);
            console.log(`   ๐ Description: ${specificAnswer.product.description || 'N/A'}`);
            console.log(`   ๐ท๏ธ Tags: ${specificAnswer.product.tags || 'N/A'}`);
            console.log(`   ๐ธ Images: ${specificAnswer.product.images || 'N/A'}`);
          }
        } else {
          console.log(`โ No specific answer found`);
        }
      } catch (error) {
        console.error(`โ Error: ${error.message}`);
      }
    }
    
    // Test 2: Check database access directly
    console.log('\n\n๐ Test 2: Testing direct database access...');
    
    const products = await prisma.product.findMany({
      where: {
        OR: [
          { name: { contains: 'ููุชุดู' } },
          { name: { contains: 'ูุงูู' } }
        ]
      },
      include: {
        category: true,
        company: true
      }
    });
    
    console.log(`โ Found ${products.length} Nike shoes in database:`);
    products.forEach((product, index) => {
      console.log(`\n๐๏ธ Product ${index + 1}:`);
      console.log(`   ๐ Name: ${product.name}`);
      console.log(`   ๐ฐ Price: ${product.price} ุฌููู`);
      console.log(`   ๐ฆ Stock: ${product.stock} ูุทุนุฉ`);
      console.log(`   ๐ Description: ${product.description}`);
      console.log(`   ๐ท๏ธ Category: ${product.category?.name || 'N/A'}`);
      console.log(`   ๐ข Company: ${product.company?.name || 'N/A'}`);
      console.log(`   ๐ข SKU: ${product.sku}`);
      console.log(`   โ Active: ${product.isActive ? 'Yes' : 'No'}`);
      
      // Test JSON fields
      if (product.tags) {
        try {
          const tags = JSON.parse(product.tags);
          console.log(`   ๐ท๏ธ Tags: ${tags.join(', ')}`);
        } catch (error) {
          console.log(`   ๐ท๏ธ Tags (raw): ${product.tags}`);
        }
      }
      
      if (product.images) {
        try {
          const images = JSON.parse(product.images);
          console.log(`   ๐ธ Images: ${images.length} images`);
        } catch (error) {
          console.log(`   ๐ธ Images (raw): ${product.images}`);
        }
      }
    });
    
    // Test 3: Test Gemini AI service with product context
    console.log('\n\n๐ค Test 3: Testing Gemini AI with product context...');
    
    const AdvancedGeminiService = require('./src/services/advancedGeminiService');
    const advancedGeminiService = new AdvancedGeminiService();
    
    // Initialize Gemini service
    await advancedGeminiService.initialize(companyId);
    
    const testMessages = [
      'ูุงู ุณุนุฑ ุงูููุชุดู ุงููุงููุ',
      'ุนูุฏูู ูุงุชู ุฐูู ูุชููุฑุ'
    ];
    
    for (const message of testMessages) {
      console.log(`\n๐ฌ Testing message: "${message}"`);
      
      try {
        // Build context with product information
        const context = {
          customer: { id: 'test-customer', firstName: 'ุฃุญูุฏ' },
          conversationHistory: [],
          availableProducts: products.slice(0, 3) // Pass some products as context
        };
        
        const response = await advancedGeminiService.generateResponse(companyId, message, context);
        
        if (response.success) {
          console.log(`โ Gemini Response: "${response.response}"`);
          console.log(`๐ Model: ${response.modelUsed}, Confidence: ${response.confidence}`);
          console.log(`โฑ๏ธ Response Time: ${response.responseTime}ms`);
        } else {
          console.log(`โ Gemini failed: ${response.error}`);
          console.log(`๐ Fallback: ${response.fallbackResponse}`);
        }
      } catch (error) {
        console.error(`โ Error with Gemini: ${error.message}`);
      }
    }
    
    // Test 4: Check if the system can answer specific questions
    console.log('\n\n๐ฏ Test 4: End-to-end question answering...');
    
    const endToEndTests = [
      {
        question: 'ูุงู ุณุนุฑ ุงูููุชุดู ุงููุงููุ',
        expectedInfo: ['ุณุนุฑ', 'ูุงูู', 'ุฌููู']
      },
      {
        question: 'ุงููุงุชู ุงูุฐูู ูุชููุฑุ',
        expectedInfo: ['ูุชููุฑ', 'ูุงุชู', 'ูุทุนุฉ']
      }
    ];
    
    for (const test of endToEndTests) {
      console.log(`\nโ Question: "${test.question}"`);
      
      // Step 1: Try specific answer first
      const specificAnswer = await handleSpecificProductQuestion(test.question, companyId);
      
      if (specificAnswer) {
        console.log(`โ Specific answer found: "${specificAnswer.answer}"`);
        
        // Check if answer contains expected information
        const hasExpectedInfo = test.expectedInfo.every(info => 
          specificAnswer.answer.includes(info)
        );
        
        console.log(`๐ Contains expected info: ${hasExpectedInfo ? 'โ YES' : 'โ NO'}`);
        console.log(`๐ Expected: ${test.expectedInfo.join(', ')}`);
      } else {
        console.log(`โ No specific answer found`);
        
        // Fallback to Gemini
        try {
          const context = { customer: { id: 'test' }, conversationHistory: [] };
          const geminiResponse = await advancedGeminiService.generateResponse(companyId, test.question, context);
          
          if (geminiResponse.success) {
            console.log(`๐ค Gemini fallback: "${geminiResponse.response}"`);
          } else {
            console.log(`โ Gemini also failed`);
          }
        } catch (error) {
          console.log(`โ Gemini error: ${error.message}`);
        }
      }
    }
    
    console.log('\n๐ Gemini Product Access Test Complete!');
    
  } catch (error) {
    console.error('โ Test failed:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Helper function to handle specific product questions
async function handleSpecificProductQuestion(messageText, companyId) {
  const text = messageText.toLowerCase();
  
  // Extract product keywords
  const keywords = [];
  const productTerms = [
    'ููุชุดู', 'ุญุฐุงุก', 'ุฌุฒูุฉ', 'ูุงูู', 'ุงุฏูุฏุงุณ',
    'ุชูุดูุฑุช', 'ูููุต', 'ุจููุฒุฉ', 'ูุณุชุงู', 'ูุทูู',
    'ุจูุทููู', 'ุฌููุฒ', 'ุดูุฑุช',
    'ูุงุจุชูุจ', 'ููุจููุชุฑ', 'ููุจุงูู', 'ุชููููู', 'ูุงุชู', 'ุฐูู',
    'ุณุงุนุฉ', 'ูุธุงุฑุฉ', 'ุดูุทุฉ', 'ูุญูุธุฉ',
    'ุทูู', 'ุฃุฏูุงุช', 'ูุทุจุฎ'
  ];
  
  productTerms.forEach(term => {
    if (text.includes(term)) {
      keywords.push(term);
    }
  });
  
  if (keywords.length === 0) {
    return null;
  }
  
  try {
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();
    
    const products = await prisma.product.findMany({
      where: {
        isActive: true,
        OR: keywords.map(keyword => ({
          OR: [
            { name: { contains: keyword } },
            { description: { contains: keyword } },
            { tags: { contains: keyword } }
          ]
        }))
      },
      include: {
        category: true,
        company: true
      },
      take: 3
    });
    
    await prisma.$disconnect();
    
    if (products.length === 0) {
      return null;
    }
    
    const product = products[0];
    let questionType = 'general';
    let answer = '';
    
    // Determine question type and generate answer
    if (/ุณุนุฑ|ูุงู|ุจูุงู|ุชูููุฉ|ุซูู/.test(text)) {
      questionType = 'price';
      answer = `๐ฐ ุณุนุฑ ${product.name}: ${product.price} ุฌููู`;
    } else if (/ูุชุงุญ|ููุฌูุฏ|ูู ุงููุฎุฒู|ูุชููุฑ|ูููุฉ/.test(text)) {
      questionType = 'availability';
      answer = `๐ฆ ุญุงูุฉ ุงูุชููุฑ ูู ${product.name}:\n`;
      if (product.stock > 0) {
        answer += `โ ูุชููุฑ (${product.stock} ูุทุนุฉ)\n๐ฐ ุงูุณุนุฑ: ${product.price} ุฌููู`;
      } else {
        answer += `โ ุบูุฑ ูุชููุฑ ุญุงููุงู\n๐ ููููู ุทูุจ ุฅุดุนุงุฑ ุนูุฏ ุงูุชููุฑ`;
      }
    } else if (/ููุงุตูุงุช|ุชูุงุตูู|ูุนูููุงุช|ุฎุตุงุฆุต|ูุตู/.test(text)) {
      questionType = 'specifications';
      answer = `๐ ุชูุงุตูู ${product.name}:\n`;
      answer += `๐ ุงููุตู: ${product.description || 'ููุชุฌ ุนุงูู ุงูุฌูุฏุฉ'}\n`;
      answer += `๐ฐ ุงูุณุนุฑ: ${product.price} ุฌููู\n`;
      answer += `๐ฆ ุงููุฎุฒูู: ${product.stock} ูุทุนุฉ\n`;
      if (product.category) {
        answer += `๐ท๏ธ ุงููุฆุฉ: ${product.category.name}`;
      }
    } else {
      answer = `โน๏ธ ูุนูููุงุช ุนู ${product.name}:\n`;
      answer += `๐ ${product.description || 'ููุชุฌ ุนุงูู ุงูุฌูุฏุฉ'}\n`;
      answer += `๐ฐ ุงูุณุนุฑ: ${product.price} ุฌููู\n`;
      if (product.stock > 0) {
        answer += `โ ูุชููุฑ (${product.stock} ูุทุนุฉ)`;
      } else {
        answer += `โ ุบูุฑ ูุชููุฑ ุญุงููุงู`;
      }
    }
    
    return {
      answer,
      product,
      questionType,
      hasSpecificInfo: true
    };
    
  } catch (error) {
    console.error('Error in handleSpecificProductQuestion:', error);
    return null;
  }
}

testGeminiProductAccess();
