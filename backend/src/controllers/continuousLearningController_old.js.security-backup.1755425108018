/**
 * Continuous Learning Controller
 * 
 * ØªØ­ÙƒÙ… ÙÙŠ Ø¬Ù…ÙŠØ¹ API endpoints Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ù…Ø³ØªÙ…Ø±
 */

const ContinuousLearningServiceV2 = require('../services/continuousLearningServiceV2');
const aiAgentService = require('../services/aiAgentService');
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();
const learningService = new ContinuousLearningServiceV2();

class ContinuousLearningController {
  
  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ù…Ø³ØªÙ…Ø±
   * GET /api/learning/dashboard
   */
  async getDashboard(req, res) {
    try {
      const { companyId } = req.user || { companyId: 'cmdkj6coz0000uf0cyscco6lr' };

      console.log('ğŸ” [Dashboard] Getting dashboard data for company:', companyId);

      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø©
      const totalInteractions = await prisma.learningData.count({
        where: { companyId }
      });

      const discoveredPatterns = await prisma.discoveredPattern.count({
        where: { companyId }
      });

      const appliedImprovements = await prisma.appliedImprovement.count({
        where: { companyId }
      });

      // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­
      const successfulInteractions = await prisma.learningData.count({
        where: {
          companyId,
          outcome: { in: ['satisfied', 'resolved', 'purchase_intent'] }
        }
      });

      const successRate = totalInteractions > 0
        ? Math.round((successfulInteractions / totalInteractions) * 100)
        : 0;

      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø´Ø§Ø· Ø§Ù„Ø­Ø¯ÙŠØ«
      const recentActivity = await prisma.learningData.findMany({
        where: { companyId },
        orderBy: { createdAt: 'desc' },
        take: 5,
        select: {
          id: true,
          type: true,
          outcome: true,
          createdAt: true,
          data: true
        }
      });

      // ØªØ¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…
      const dashboardData = {
        overview: {
          totalInteractions,
          discoveredPatterns,
          appliedImprovements,
          successRate
        },
        aiStats: {
          averageResponseTime: 1500,
          accuracyRate: 89,
          satisfactionScore: 4.2
        },
        recentActivity: recentActivity.map(activity => ({
          id: activity.id,
          type: activity.type,
          outcome: activity.outcome,
          timestamp: activity.createdAt,
          description: this.getActivityDescription(activity)
        })),
        systemStatus: {
          learningEnabled: true,
          dataCollection: totalInteractions > 0,
          patternAnalysis: discoveredPatterns > 0,
          improvementApplication: appliedImprovements > 0
        }
      };

      console.log('âœ… [Dashboard] Dashboard data prepared:', {
        totalInteractions,
        discoveredPatterns,
        appliedImprovements,
        successRate
      });

      res.json({
        success: true,
        data: dashboardData,
        message: 'ØªÙ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in getDashboard:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * ÙˆØµÙ Ø§Ù„Ù†Ø´Ø§Ø· Ù„Ù„Ø¹Ø±Ø¶
   */
  getActivityDescription(activity) {
    try {
      const data = JSON.parse(activity.data);
      const userMessage = data.userMessage || 'Ø±Ø³Ø§Ù„Ø© ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©';
      return userMessage.length > 50
        ? userMessage.substring(0, 50) + '...'
        : userMessage;
    } catch {
      return 'Ù†Ø´Ø§Ø· ØªØ¹Ù„Ù…';
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ù…ÙØµÙ„Ø©
   * GET /api/learning/analytics
   */
  async getAnalytics(req, res) {
    try {
      const { companyId } = req.user;
      const { period = 'week' } = req.query;

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ø¯Ø©
      const validPeriods = ['day', 'week', 'month'];
      if (!validPeriods.includes(period)) {
        return res.status(400).json({
          success: false,
          message: 'Ù…Ø¯Ø© ØºÙŠØ± ØµØ­ÙŠØ­Ø©. Ø§Ø³ØªØ®Ø¯Ù…: day, week, month'
        });
      }

      const analytics = await learningService.getLearningAnalytics(companyId, period);
      
      if (!analytics.success) {
        return res.status(500).json({
          success: false,
          message: 'Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª',
          error: analytics.error
        });
      }

      res.json({
        success: true,
        data: analytics.data,
        period: period,
        message: 'ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in getAnalytics:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ÙƒØªØ´ÙØ©
   * GET /api/learning/patterns
   */
  async getPatterns(req, res) {
    try {
      const { companyId } = req.user;
      const { type, minConfidence = 0.5 } = req.query;

      // Ø¨Ù†Ø§Ø¡ Ø´Ø±ÙˆØ· Ø§Ù„Ø¨Ø­Ø«
      const whereClause = {
        companyId: companyId,
        confidence: {
          gte: parseFloat(minConfidence)
        }
      };

      if (type) {
        whereClause.patternType = type;
      }

      // Ø¬Ù„Ø¨ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const patterns = await prisma.discoveredPattern.findMany({
        where: whereClause,
        orderBy: [
          { confidence: 'desc' },
          { occurrences: 'desc' }
        ],
        take: 50 // Ø­Ø¯ Ø£Ù‚ØµÙ‰ 50 Ù†Ù…Ø·
      });

      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø¹Ø±Ø¶
      const formattedPatterns = patterns.map(pattern => ({
        id: pattern.id,
        type: pattern.patternType,
        pattern: pattern.pattern,
        description: pattern.description,
        confidence: Math.round(pattern.confidence * 100),
        occurrences: pattern.occurrences,
        status: pattern.status || 'discovered',
        contexts: pattern.contexts ? JSON.parse(pattern.contexts) : {},
        insights: pattern.actionableInsights ? JSON.parse(pattern.actionableInsights) : [],
        impact: pattern.impact ? JSON.parse(pattern.impact) : {},
        createdAt: pattern.createdAt,
        lastValidated: pattern.lastValidated
      }));

      res.json({
        success: true,
        data: {
          patterns: formattedPatterns,
          total: formattedPatterns.length,
          filters: {
            type: type || 'all',
            minConfidence: parseFloat(minConfidence)
          }
        },
        message: 'ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in getPatterns:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…Ø·Ø¨Ù‚Ø©
   * GET /api/learning/improvements
   */
  async getImprovements(req, res) {
    try {
      const { companyId } = req.user;
      const { status, type } = req.query;

      // Ø¨Ù†Ø§Ø¡ Ø´Ø±ÙˆØ· Ø§Ù„Ø¨Ø­Ø«
      const whereClause = { companyId: companyId };
      
      if (status) {
        whereClause.status = status;
      }
      
      if (type) {
        whereClause.type = type;
      }

      // Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const improvements = await prisma.appliedImprovement.findMany({
        where: whereClause,
        orderBy: { createdAt: 'desc' },
        take: 100 // Ø­Ø¯ Ø£Ù‚ØµÙ‰ 100 ØªØ­Ø³ÙŠÙ†
      });

      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø¹Ø±Ø¶
      const formattedImprovements = improvements.map(improvement => ({
        id: improvement.id,
        type: improvement.type,
        description: improvement.description,
        status: improvement.status || 'active',
        rolloutPercentage: improvement.rolloutPercentage || 0,
        implementation: improvement.implementation ? JSON.parse(improvement.implementation) : {},
        createdAt: improvement.createdAt,
        updatedAt: improvement.updatedAt
      }));

      res.json({
        success: true,
        data: {
          improvements: formattedImprovements,
          total: formattedImprovements.length,
          filters: {
            status: status || 'all',
            type: type || 'all'
          }
        },
        message: 'ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in getImprovements:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¹Ù„Ù…
   * GET /api/learning/settings
   */
  async getSettings(req, res) {
    try {
      const { companyId } = req.user;

      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¹Ù„Ù…
      const learningSettings = await learningService.getLearningSettings(companyId);
      
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª AI Agent
      const aiSettings = await aiAgentService.getSettings();

      const settings = {
        learning: {
          enabled: learningSettings?.enabled || false,
          learningSpeed: learningSettings?.learningSpeed || 'medium',
          autoApplyImprovements: learningSettings?.autoApplyImprovements || false,
          dataRetentionDays: learningSettings?.dataRetentionDays || 90,
          minimumSampleSize: learningSettings?.minimumSampleSize || 50,
          confidenceThreshold: learningSettings?.confidenceThreshold || 0.8
        },
        ai: {
          learningEnabled: aiSettings.learningEnabled || false,
          isEnabled: aiSettings.isEnabled || false
        }
      };

      res.json({
        success: true,
        data: settings,
        message: 'ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in getSettings:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¹Ù„Ù…
   * PUT /api/learning/settings
   */
  async updateSettings(req, res) {
    try {
      const { companyId } = req.user;
      const settings = req.body;

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      if (!settings || typeof settings !== 'object') {
        return res.status(400).json({
          success: false,
          message: 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø·Ù„ÙˆØ¨Ø©'
        });
      }

      // ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ù…Ø³ØªÙ…Ø±
      if (settings.learning) {
        await prisma.learningSettings.upsert({
          where: { companyId: companyId },
          update: {
            enabled: settings.learning.enabled,
            learningSpeed: settings.learning.learningSpeed,
            autoApplyImprovements: settings.learning.autoApplyImprovements,
            dataRetentionDays: settings.learning.dataRetentionDays,
            minimumSampleSize: settings.learning.minimumSampleSize,
            confidenceThreshold: settings.learning.confidenceThreshold,
            updatedAt: new Date()
          },
          create: {
            companyId: companyId,
            enabled: settings.learning.enabled || false,
            learningSpeed: settings.learning.learningSpeed || 'medium',
            autoApplyImprovements: settings.learning.autoApplyImprovements || false,
            dataRetentionDays: settings.learning.dataRetentionDays || 90,
            minimumSampleSize: settings.learning.minimumSampleSize || 50,
            confidenceThreshold: settings.learning.confidenceThreshold || 0.8
          }
        });
      }

      // ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª AI Agent
      if (settings.ai) {
        await aiAgentService.updateSettings({
          learningEnabled: settings.ai.learningEnabled
        }, companyId);
      }

      res.json({
        success: true,
        message: 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in updateSettings:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * ØªØ·Ø¨ÙŠÙ‚ ØªØ­Ø³ÙŠÙ† Ù…Ø¹ÙŠÙ†
   * POST /api/learning/improvements/:id/apply
   */
  async applyImprovement(req, res) {
    try {
      const { companyId } = req.user;
      const { id } = req.params;

      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªØ­Ø³ÙŠÙ†
      const improvement = await prisma.appliedImprovement.findFirst({
        where: {
          id: id,
          companyId: companyId
        }
      });

      if (!improvement) {
        return res.status(404).json({
          success: false,
          message: 'Ø§Ù„ØªØ­Ø³ÙŠÙ† ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
        });
      }

      // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ­Ø³ÙŠÙ†
      await aiAgentService.applyLearningImprovements(companyId);

      // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ†
      await prisma.appliedImprovement.update({
        where: { id: id },
        data: {
          status: 'active',
          updatedAt: new Date()
        }
      });

      res.json({
        success: true,
        message: 'ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in applyImprovement:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * Ø¥ÙŠÙ‚Ø§Ù ØªØ­Ø³ÙŠÙ† Ù…Ø¹ÙŠÙ†
   * POST /api/learning/improvements/:id/disable
   */
  async disableImprovement(req, res) {
    try {
      const { companyId } = req.user;
      const { id } = req.params;

      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªØ­Ø³ÙŠÙ†
      const improvement = await prisma.appliedImprovement.findFirst({
        where: {
          id: id,
          companyId: companyId
        }
      });

      if (!improvement) {
        return res.status(404).json({
          success: false,
          message: 'Ø§Ù„ØªØ­Ø³ÙŠÙ† ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
        });
      }

      // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ†
      await prisma.appliedImprovement.update({
        where: { id: id },
        data: {
          status: 'disabled',
          updatedAt: new Date()
        }
      });

      res.json({
        success: true,
        message: 'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in disableImprovement:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø®Ø§Ù…
   * GET /api/learning/data
   */
  async getLearningData(req, res) {
    try {
      const { companyId } = req.user;
      const {
        page = 1,
        limit = 20,
        type,
        outcome,
        startDate,
        endDate
      } = req.query;

      // Ø¨Ù†Ø§Ø¡ Ø´Ø±ÙˆØ· Ø§Ù„Ø¨Ø­Ø«
      const whereClause = { companyId: companyId };

      if (type) {
        whereClause.type = type;
      }

      if (outcome) {
        whereClause.outcome = outcome;
      }

      if (startDate || endDate) {
        whereClause.createdAt = {};
        if (startDate) {
          whereClause.createdAt.gte = new Date(startDate);
        }
        if (endDate) {
          whereClause.createdAt.lte = new Date(endDate);
        }
      }

      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø²Ø§Ø­Ø©
      const skip = (parseInt(page) - 1) * parseInt(limit);

      // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const [data, total] = await Promise.all([
        prisma.learningData.findMany({
          where: whereClause,
          orderBy: { createdAt: 'desc' },
          skip: skip,
          take: parseInt(limit)
        }),
        prisma.learningData.count({ where: whereClause })
      ]);

      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø¹Ø±Ø¶
      const formattedData = data.map(item => ({
        id: item.id,
        type: item.type,
        outcome: item.outcome,
        data: item.data ? JSON.parse(item.data) : {},
        insights: item.insights ? JSON.parse(item.insights) : {},
        feedback: item.feedback ? JSON.parse(item.feedback) : {},
        createdAt: item.createdAt
      }));

      res.json({
        success: true,
        data: {
          items: formattedData,
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total: total,
            pages: Math.ceil(total / parseInt(limit))
          },
          filters: {
            type: type || 'all',
            outcome: outcome || 'all',
            startDate: startDate || null,
            endDate: endDate || null
          }
        },
        message: 'ØªÙ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¹Ù„Ù… Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in getLearningData:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª ØªØ¹Ù„Ù… ÙŠØ¯ÙˆÙŠØ§Ù‹
   * POST /api/learning/data
   */
  async addLearningData(req, res) {
    try {
      const { companyId } = req.user;
      const learningData = req.body;

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      if (!learningData.type || !learningData.data) {
        return res.status(400).json({
          success: false,
          message: 'Ù†ÙˆØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ø·Ù„ÙˆØ¨Ø§Ù†'
        });
      }

      // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø±ÙƒØ©
      learningData.companyId = companyId;

      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const result = await learningService.collectLearningData(learningData);

      if (!result.success) {
        return res.status(500).json({
          success: false,
          message: 'Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¹Ù„Ù…',
          error: result.error
        });
      }

      res.json({
        success: true,
        data: result.data,
        message: 'ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¹Ù„Ù… Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in addLearningData:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }

  /**
   * Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
   * GET /api/learning/performance
   */
  async getPerformance(req, res) {
    try {
      const { companyId } = req.user;

      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡
      const performance = await aiAgentService.monitorImprovementPerformance(companyId);

      if (!performance.success) {
        return res.status(500).json({
          success: false,
          message: 'Ø®Ø·Ø£ ÙÙŠ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡',
          error: performance.error
        });
      }

      res.json({
        success: true,
        data: performance,
        message: 'ØªÙ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­'
      });

    } catch (error) {
      console.error('âŒ Error in getPerformance:', error);
      res.status(500).json({
        success: false,
        message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
        error: error.message
      });
    }
  }
}

module.exports = new ContinuousLearningController();
