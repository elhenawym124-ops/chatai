const express = require('express');
const router = express.Router();

// Set UTF-8 encoding for console output
process.stdout.setEncoding('utf8');
process.stderr.setEncoding('utf8');

// Import controllers and middleware
// Mock authentication middleware for testing
const mockAuth = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return res.status(401).json({
      success: false,
      error: 'Authentication required',
      message: 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹'
    });
  }

  // Accept mock token from login or development mock token
  if (token === 'mock-access-token' || token.includes('mock-signature')) {
    req.user = {
      id: 'dev-user',
      email: 'dev@example.com',
      role: 'COMPANY_ADMIN',
      companyId: 'cmd5c0c9y0000ymzdd7wtv7ib'
    };
    return next();
  }

  return res.status(401).json({
    success: false,
    error: 'Invalid token',
    message: 'ØªÙˆÙƒÙ† ØºÙŠØ± ØµØ­ÙŠØ­'
  });
};

// Mock product controller for now
const productController = {
  getProducts: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      // Ø¬Ù„Ø¨ companyId Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ØµØ§Ø¯Ù‚ Ø¹Ù„ÙŠÙ‡ ÙÙ‚Ø·
      const companyId = req.user?.companyId;

      if (!companyId) {
        return res.status(403).json({
          success: false,
          message: 'ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ - Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø±ÙƒØ© Ù…Ø·Ù„ÙˆØ¨'
        });
      }

      console.log('Fetching products from database for company:', companyId);

      // Ø¨Ù†Ø§Ø¡ where clause Ù…Ø¹ ÙÙ„ØªØ±Ø© companyId Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠØ©
      const whereClause = { companyId };

      // Get products from database
      const products = await prisma.product.findMany({
        where: whereClause,
        include: {
          category: true,
          company: true,
          variants: {
            where: { isActive: true },
            orderBy: { sortOrder: 'asc' }
          }
        },
        orderBy: {
          createdAt: 'desc'
        }
      });

      console.log(`Found ${products.length} products in database`);

      // Process products to ensure JSON fields are properly parsed
      const processedProducts = products.map(product => {
        const processedProduct = { ...product };

        // Safely parse JSON fields
        try {
          processedProduct.images = product.images ? JSON.parse(product.images) : [];
        } catch (error) {
          console.warn(`Failed to parse images for product ${product.id}:`, product.images);
          processedProduct.images = [];
        }

        try {
          processedProduct.tags = product.tags ? JSON.parse(product.tags) : [];
        } catch (error) {
          console.warn(`Failed to parse tags for product ${product.id}:`, product.tags);
          processedProduct.tags = [];
        }

        try {
          processedProduct.dimensions = product.dimensions ? JSON.parse(product.dimensions) : null;
        } catch (error) {
          console.warn(`Failed to parse dimensions for product ${product.id}:`, product.dimensions);
          processedProduct.dimensions = null;
        }

        return processedProduct;
      });

      await prisma.$disconnect();

      res.json({
        success: true,
        data: processedProducts,
        pagination: {
          page: 1,
          limit: 100,
          total: products.length,
          pages: 1
        }
      });
    } catch (error) {
      console.error('Error fetching products:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch products',
        details: error.message
      });
    }
  },

  getProduct: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const productId = req.params.id;

      console.log('Fetching product:', productId);

      // Get product from database with variants
      const product = await prisma.product.findUnique({
        where: { id: productId },
        include: {
          category: true,
          company: true,
          variants: {
            orderBy: { sortOrder: 'asc' }
          }
        }
      });

      if (!product) {
        await prisma.$disconnect();
        return res.status(404).json({
          success: false,
          error: 'Product not found'
        });
      }

      console.log('Product found:', product);

      // Process product to ensure JSON fields are properly parsed
      const processedProduct = { ...product };

      try {
        processedProduct.images = product.images ? JSON.parse(product.images) : [];
      } catch (error) {
        console.warn(`Failed to parse images for product ${product.id}:`, product.images);
        processedProduct.images = [];
      }

      try {
        processedProduct.tags = product.tags ? JSON.parse(product.tags) : [];
      } catch (error) {
        console.warn(`Failed to parse tags for product ${product.id}:`, product.tags);
        processedProduct.tags = [];
      }

      try {
        processedProduct.dimensions = product.dimensions ? JSON.parse(product.dimensions) : null;
      } catch (error) {
        console.warn(`Failed to parse dimensions for product ${product.id}:`, product.dimensions);
        processedProduct.dimensions = null;
      }

      await prisma.$disconnect();

      res.json({
        success: true,
        data: processedProduct
      });
    } catch (error) {
      console.error('Error fetching product:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch product'
      });
    }
  },

  getCategories: async (req, res) => {
    try {
      console.log('ğŸ” Getting categories from database...');

      // Get user from auth middleware
      const user = req.user || { companyId: 'cmd5c0c9y0000ymzdd7wtv7ib' };

      // Get categories from database
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const categories = await prisma.category.findMany({
        where: { companyId: user.companyId },
        include: {
          _count: {
            select: { products: true }
          }
        },
        orderBy: { name: 'asc' }
      });

      console.log('ğŸ“¦ Categories found:', categories.length);

      await prisma.$disconnect();

      res.json({
        success: true,
        data: categories
      });
    } catch (error) {
      console.error('âŒ Error fetching categories:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch categories'
      });
    }
  },

  createCategory: async (req, res) => {
    try {
      console.log('ğŸ” Creating new category...');

      const { name, description } = req.body;

      if (!name || !name.trim()) {
        return res.status(400).json({
          success: false,
          error: 'Category name is required'
        });
      }

      // Get user from auth middleware
      const user = req.user || { companyId: 'cmd5c0c9y0000ymzdd7wtv7ib' };

      // Create category in database
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const category = await prisma.category.create({
        data: {
          name: name.trim(),
          description: description ? description.trim() : null,
          companyId: user.companyId
        },
        include: {
          _count: {
            select: { products: true }
          }
        }
      });

      console.log('âœ… Category created:', category.name);

      await prisma.$disconnect();

      res.json({
        success: true,
        data: category,
        message: 'Category created successfully'
      });
    } catch (error) {
      console.error('âŒ Error creating category:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create category'
      });
    }
  },

  updateCategory: async (req, res) => {
    try {
      console.log('ğŸ” Updating category...');

      const { id } = req.params;
      const { name, description } = req.body;

      if (!name || !name.trim()) {
        return res.status(400).json({
          success: false,
          error: 'Category name is required'
        });
      }

      // Get user from auth middleware
      const user = req.user || { companyId: 'cmd5c0c9y0000ymzdd7wtv7ib' };

      // Update category in database
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      // Check if category exists and belongs to company
      const existingCategory = await prisma.category.findFirst({
        where: {
          id: id,
          companyId: user.companyId
        }
      });

      if (!existingCategory) {
        await prisma.$disconnect();
        return res.status(404).json({
          success: false,
          error: 'Category not found'
        });
      }

      const category = await prisma.category.update({
        where: { id: id },
        data: {
          name: name.trim(),
          description: description ? description.trim() : null
        },
        include: {
          _count: {
            select: { products: true }
          }
        }
      });

      console.log('âœ… Category updated:', category.name);

      await prisma.$disconnect();

      res.json({
        success: true,
        data: category,
        message: 'Category updated successfully'
      });
    } catch (error) {
      console.error('âŒ Error updating category:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update category'
      });
    }
  },

  cleanupCategories: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      console.log('ğŸ§¹ Starting categories cleanup...');

      // Get all categories
      const categories = await prisma.category.findMany({
        include: {
          products: true
        }
      });

      console.log(`ğŸ“Š Found ${categories.length} categories to analyze`);

      // Find duplicates based on name
      const duplicates = [];
      const seen = new Map();
      
      categories.forEach(category => {
        const key = category.name.toLowerCase().trim();
        if (seen.has(key)) {
          duplicates.push({
            original: seen.get(key),
            duplicate: category
          });
        } else {
          seen.set(key, category);
        }
      });

      console.log(`ğŸ” Found ${duplicates.length} duplicate categories`);

      let cleanedCount = 0;
      const cleanupResults = [];

      // Process each duplicate
      for (const { original, duplicate } of duplicates) {
        try {
          // Move products from duplicate to original category
          if (duplicate.products.length > 0) {
            // FIXED: Add company isolation for security
            await prisma.product.updateMany({
              where: {
                categoryId: duplicate.id,
                companyId: req.user.companyId // Company isolation
              },
              data: { categoryId: original.id }
            });
            console.log(`ğŸ“¦ Moved ${duplicate.products.length} products from duplicate category '${duplicate.name}' to original`);
          }

          // Delete the duplicate category
          await prisma.category.delete({
            where: { id: duplicate.id }
          });

          cleanedCount++;
          cleanupResults.push({
            action: 'deleted',
            category: duplicate.name,
            productsMovedTo: original.name,
            productsCount: duplicate.products.length
          });

          console.log(`âœ… Deleted duplicate category: ${duplicate.name}`);
        } catch (error) {
          console.error(`âŒ Error cleaning up category ${duplicate.name}:`, error);
          cleanupResults.push({
            action: 'error',
            category: duplicate.name,
            error: error.message
          });
        }
      }

      await prisma.$disconnect();

      console.log(`ğŸ‰ Cleanup completed! Removed ${cleanedCount} duplicate categories`);

      res.json({
        success: true,
        message: `ØªÙ… ØªÙ†Ø¸ÙŠÙ ${cleanedCount} ÙØ¦Ø© Ù…ÙƒØ±Ø±Ø© Ø¨Ù†Ø¬Ø§Ø­`,
        data: {
          totalCategories: categories.length,
          duplicatesFound: duplicates.length,
          duplicatesRemoved: cleanedCount,
          results: cleanupResults
        }
      });
    } catch (error) {
      console.error('âŒ Error during categories cleanup:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to cleanup categories',
        message: 'ÙØ´Ù„ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙØ¦Ø§Øª',
        details: error.message
      });
    }
  },

  deleteCategory: async (req, res) => {
    try {
      console.log('ğŸ” Deleting category...');

      const { id } = req.params;

      // Get user from auth middleware
      const user = req.user || { companyId: 'cmd5c0c9y0000ymzdd7wtv7ib' };

      // Delete category from database
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      // Check if category exists and belongs to company
      const existingCategory = await prisma.category.findFirst({
        where: {
          id: id,
          companyId: user.companyId
        },
        include: {
          _count: {
            select: { products: true }
          }
        }
      });

      if (!existingCategory) {
        await prisma.$disconnect();
        return res.status(404).json({
          success: false,
          error: 'Category not found'
        });
      }

      // Check if category has products
      if (existingCategory._count.products > 0) {
        await prisma.$disconnect();
        return res.status(400).json({
          success: false,
          error: `Cannot delete category with ${existingCategory._count.products} products`
        });
      }

      await prisma.category.delete({
        where: { id: id }
      });

      console.log('âœ… Category deleted:', existingCategory.name);

      await prisma.$disconnect();

      res.json({
        success: true,
        message: 'Category deleted successfully'
      });
    } catch (error) {
      console.error('âŒ Error deleting category:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete category'
      });
    }
  },

  createProduct: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const productData = req.body;
      console.log('Creating product with data:', productData);

      // Validate required fields
      if (!productData.name || !productData.price) {
        return res.status(400).json({
          success: false,
          error: 'Name and price are required'
        });
      }

      // FIXED: Get company ID from authenticated user instead of first company
      const companyId = req.user?.companyId;

      if (!companyId) {
        return res.status(401).json({
          success: false,
          error: 'Company ID not found in user context'
        });
      }

      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: 'No company found in database'
        });
      }

      // Get or create default category
      let categoryId = null;
      if (productData.category) {
        let category = await prisma.category.findFirst({
          where: {
            name: productData.category,
            companyId: companyId
          }
        });

        if (!category) {
          category = await prisma.category.create({
            data: {
              name: productData.category,
              companyId: companyId
            }
          });
        }
        categoryId = category.id;
      }

      // Handle SKU - only validate if provided
      let sku = productData.sku || null;
      if (sku) {
        // Ensure SKU is unique if provided
        const skuExists = await prisma.product.findUnique({ where: { sku } });
        if (skuExists) {
          return res.status(400).json({
            success: false,
            error: 'SKU already exists. Please use a different SKU.'
          });
        }
      }

      // Create product in database
      const newProduct = await prisma.product.create({
        data: {
          name: productData.name,
          description: productData.description || '',
          price: parseFloat(productData.price),
          sku: sku,
          stock: parseInt(productData.stock) || 0,
          isActive: productData.isActive !== false,
          categoryId: categoryId,
          companyId: companyId,
          tags: productData.tags ? JSON.stringify(productData.tags) : null,
          images: productData.images ? JSON.stringify(productData.images) : null
        },
        include: {
          category: true,
          company: true
        }
      });

      console.log('Product created successfully:', newProduct);

      await prisma.$disconnect();

      // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù†ØªØ¬ Ø¬Ø¯ÙŠØ¯
      try {
        const ragService = require('../services/ragService');
        await ragService.updateKnowledgeBase();
        console.log('âœ… RAG Knowledge Base updated after product creation');
      } catch (ragError) {
        console.error('âš ï¸ Failed to update RAG after product creation:', ragError.message);
        // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
      }

      res.status(201).json({
        success: true,
        data: newProduct,
        message: 'Product created successfully'
      });
    } catch (error) {
      console.error('Error creating product:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create product',
        details: error.message
      });
    }
  },

  updateProduct: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const productId = req.params.id;
      const updateData = { ...req.body };

      console.log('Updating product:', productId, 'with data:', updateData);

      // Handle category field - convert category to categoryId
      if (updateData.category) {
        // First, try to find category by name (for cases like "1", "2", "3", etc.)
        const categoryByName = await prisma.category.findFirst({
          where: {
            name: updateData.category,
            companyId: updateData.companyId || 'cmd5c0c9y0000ymzdd7wtv7ib' // Default company ID
          }
        });

        if (categoryByName) {
          updateData.categoryId = categoryByName.id;
        } else {
          // If not found by name, try to use it as an ID directly
          const categoryById = await prisma.category.findUnique({
            where: { id: updateData.category }
          });

          if (categoryById) {
            updateData.categoryId = updateData.category;
          } else {
            // If neither name nor ID works, use the first available category
            const firstCategory = await prisma.category.findFirst({
              where: {
                companyId: updateData.companyId || 'cmd5c0c9y0000ymzdd7wtv7ib'
              }
            });
            if (firstCategory) {
              updateData.categoryId = firstCategory.id;
              console.log(`Category "${updateData.category}" not found, using first available category: ${firstCategory.name} (${firstCategory.id})`);
            }
          }
        }
        delete updateData.category;
      }

      // Update product in database
      const updatedProduct = await prisma.product.update({
        where: { id: productId },
        data: updateData,
        include: {
          category: true,
          company: true
        }
      });

      console.log('Product updated successfully:', updatedProduct);

      await prisma.$disconnect();

      // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù†ØªØ¬
      try {
        const ragService = require('../services/ragService');
        await ragService.updateKnowledgeBase();
        console.log('âœ… RAG Knowledge Base updated after product update');
      } catch (ragError) {
        console.error('âš ï¸ Failed to update RAG after product update:', ragError.message);
        // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
      }

      res.json({
        success: true,
        data: updatedProduct
      });
    } catch (error) {
      console.error('Error updating product:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update product'
      });
    }
  },

  deleteProduct: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const productId = req.params.id;

      console.log('Deleting product:', productId);

      // Delete product from database
      await prisma.product.delete({
        where: { id: productId }
      });

      console.log('Product deleted successfully');

      await prisma.$disconnect();

      // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ Ø­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬
      try {
        const ragService = require('../services/ragService');
        await ragService.updateKnowledgeBase();
        console.log('âœ… RAG Knowledge Base updated after product deletion');
      } catch (ragError) {
        console.error('âš ï¸ Failed to update RAG after product deletion:', ragError.message);
        // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
      }

      res.json({
        success: true,
        message: 'Product deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting product:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete product'
      });
    }
  },

  // Product Variants Controllers
  getProductVariants: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const productId = req.params.id;

      console.log('Fetching variants for product:', productId);

      // Get product variants from database
      const variants = await prisma.productVariant.findMany({
      where: { product: { companyId: req.user?.companyId } },
        where: { productId: productId },
        orderBy: { sortOrder: 'asc' }
      });

      console.log('Found variants:', variants.length);

      await prisma.$disconnect();

      res.json({
        success: true,
        data: variants
      });
    } catch (error) {
      console.error('Error fetching product variants:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch product variants'
      });
    }
  },

  createProductVariant: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const productId = req.params.id;
      const variantData = req.body;

      console.log('Creating variant for product:', productId, 'with data:', variantData);

      // Handle variant SKU - only validate if provided
      let variantSku = variantData.sku || null;
      if (variantSku) {
        // Ensure variant SKU is unique if provided
        const variantSkuExists = await prisma.productVariant.findUnique({ where: { sku: variantSku } });
        if (variantSkuExists) {
          return res.status(400).json({
            success: false,
            error: 'Variant SKU already exists. Please use a different SKU.'
          });
        }
      }

      // Create variant in database
      const variant = await prisma.productVariant.create({
        data: {
          productId: productId,
          name: variantData.name,
          type: variantData.type || 'color',
          sku: variantSku,
          price: variantData.price ? parseFloat(variantData.price) : null,
          comparePrice: variantData.comparePrice ? parseFloat(variantData.comparePrice) : null,
          cost: variantData.cost ? parseFloat(variantData.cost) : null,
          images: variantData.images ? JSON.stringify(variantData.images) : null,
          stock: variantData.stock ? parseInt(variantData.stock) : 0,
          trackInventory: variantData.trackInventory !== undefined ? variantData.trackInventory : true,
          isActive: variantData.isActive !== undefined ? variantData.isActive : true,
          sortOrder: variantData.sortOrder || 0,
          metadata: variantData.metadata || null
        }
      });

      console.log('Variant created successfully:', variant);

      await prisma.$disconnect();

      // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ù…ØªØºÙŠØ± Ø¬Ø¯ÙŠØ¯
      try {
        const ragService = require('../services/ragService');
        await ragService.updateKnowledgeBase();
        console.log('âœ… RAG Knowledge Base updated after variant creation');
      } catch (ragError) {
        console.error('âš ï¸ Failed to update RAG after variant creation:', ragError.message);
        // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
      }

      res.status(201).json({
        success: true,
        data: variant
      });
    } catch (error) {
      console.error('Error creating product variant:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create product variant'
      });
    }
  },

  updateProductVariant: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const variantId = req.params.variantId;
      const updateData = req.body;

      console.log('Updating variant:', variantId, 'with data:', updateData);

      // Process update data - handle images array
      const processedData = { ...updateData };

      // Handle images array - convert to JSON string if it's an array
      if (processedData.images && Array.isArray(processedData.images)) {
        processedData.images = JSON.stringify(processedData.images);
        console.log('ğŸ“¸ [VARIANT-UPDATE] Converted images array to JSON string');
      }

      // Ensure numeric fields are properly typed
      if (processedData.price !== undefined) {
        processedData.price = parseFloat(processedData.price);
      }
      if (processedData.comparePrice !== undefined) {
        processedData.comparePrice = parseFloat(processedData.comparePrice);
      }
      if (processedData.cost !== undefined) {
        processedData.cost = parseFloat(processedData.cost);
      }
      if (processedData.stock !== undefined) {
        processedData.stock = parseInt(processedData.stock);
      }

      // Handle trackInventory field
      if (processedData.trackInventory !== undefined) {
        processedData.trackInventory = Boolean(processedData.trackInventory);
        console.log(`ğŸ“¦ [VARIANT-UPDATE] Track inventory: ${processedData.trackInventory}`);
      }

      // Handle empty SKU - set to null to avoid unique constraint issues
      if (processedData.sku !== undefined && processedData.sku.trim() === '') {
        processedData.sku = null;
        console.log('ğŸ·ï¸ [VARIANT-UPDATE] Empty SKU converted to null');
      }

      console.log('ğŸ”§ [VARIANT-UPDATE] Processed data:', processedData);

      // Update variant in database
      const variant = await prisma.productVariant.update({
        where: { id: variantId },
        data: processedData
      });

      console.log('Variant updated successfully:', variant);

      await prisma.$disconnect();

      // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ØªØºÙŠØ±
      try {
        const ragService = require('../services/ragService');
        await ragService.updateKnowledgeBase();
        console.log('âœ… RAG Knowledge Base updated after variant update');
      } catch (ragError) {
        console.error('âš ï¸ Failed to update RAG after variant update:', ragError.message);
        // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
      }

      res.json({
        success: true,
        data: variant
      });
    } catch (error) {
      console.error('Error updating product variant:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update product variant'
      });
    }
  },

  deleteProductVariant: async (req, res) => {
    try {
      const { PrismaClient } = require('@prisma/client');
      const prisma = new PrismaClient();

      const variantId = req.params.variantId;

      console.log('Deleting variant:', variantId);

      // Delete variant from database
      await prisma.productVariant.delete({
        where: { id: variantId }
      });

      console.log('Variant deleted successfully');

      await prisma.$disconnect();

      // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ Ø­Ø°Ù Ø§Ù„Ù…ØªØºÙŠØ±
      try {
        const ragService = require('../services/ragService');
        await ragService.updateKnowledgeBase();
        console.log('âœ… RAG Knowledge Base updated after variant deletion');
      } catch (ragError) {
        console.error('âš ï¸ Failed to update RAG after variant deletion:', ragError.message);
        // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
      }

      res.json({
        success: true,
        message: 'Product variant deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting product variant:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete product variant'
      });
    }
  }
};

// Public routes (no authentication required)
router.get('/categories', productController.getCategories);
router.post('/categories', productController.createCategory);
router.post('/categories/cleanup', productController.cleanupCategories);
router.put('/categories/:id', productController.updateCategory);
router.delete('/categories/:id', productController.deleteCategory);
router.get('/', productController.getProducts);
router.post('/', productController.createProduct);

// Product Variants routes (public for testing) - specific routes first
router.get('/:id/variants', productController.getProductVariants);
router.post('/:id/variants', productController.createProductVariant);
router.patch('/variants/:variantId', productController.updateProductVariant);
router.put('/variants/:variantId', productController.updateProductVariant); // Support both PATCH and PUT
router.patch('/:id/variants/:variantId', productController.updateProductVariant); // Alternative path
router.put('/:id/variants/:variantId', productController.updateProductVariant); // Alternative path with PUT
router.delete('/variants/:variantId', productController.deleteProductVariant);

// Image management endpoints (public for testing)

// Add image to product by URL
router.post('/:id/images', async (req, res) => {
  try {
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();

    const { id } = req.params;
    const { imageUrl, description } = req.body;

    console.log(`ğŸ“¸ [IMAGE-ADD] Adding image to product ${id}:`, imageUrl);

    if (!imageUrl) {
      return res.status(400).json({
        success: false,
        error: 'Image URL is required',
        message: 'Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨'
      });
    }

    // Validate URL format
    try {
      new URL(imageUrl);
    } catch (error) {
      return res.status(400).json({
        success: false,
        error: 'Invalid URL format',
        message: 'Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© ØºÙŠØ± ØµØ­ÙŠØ­'
      });
    }

    // Get current product
    const product = await prisma.product.findUnique({
      where: { id }
    });

    if (!product) {
      return res.status(404).json({
        success: false,
        error: 'Product not found',
        message: 'Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
      });
    }

    // Parse existing images
    let currentImages = [];
    try {
      currentImages = product.images ? JSON.parse(product.images) : [];
    } catch (error) {
      console.log('âš ï¸ [IMAGE-ADD] Error parsing existing images, starting fresh');
      currentImages = [];
    }

    // Check if image already exists
    if (currentImages.includes(imageUrl)) {
      return res.status(400).json({
        success: false,
        error: 'Image already exists',
        message: 'Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„'
      });
    }

    // Add new image
    currentImages.push(imageUrl);

    // Update product
    const updatedProduct = await prisma.product.update({
      where: { id },
      data: {
        images: JSON.stringify(currentImages)
      }
    });

    console.log(`âœ… [IMAGE-ADD] Image added successfully. Total images: ${currentImages.length}`);

    await prisma.$disconnect();

    // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ Ø¥Ø¶Ø§ÙØ© ØµÙˆØ±Ø©
    try {
      const ragService = require('../services/ragService');
      await ragService.updateKnowledgeBase();
      console.log('âœ… RAG Knowledge Base updated after image addition');
    } catch (ragError) {
      console.error('âš ï¸ Failed to update RAG after image addition:', ragError.message);
      // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
    }

    res.json({
      success: true,
      data: {
        productId: id,
        imageUrl,
        totalImages: currentImages.length,
        allImages: currentImages
      },
      message: 'ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­'
    });

  } catch (error) {
    console.error('âŒ [IMAGE-ADD] Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to add image',
      message: 'ÙØ´Ù„ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø©',
      details: error.message
    });
  }
});

// Add image to variant by URL
router.post('/:id/variants/:variantId/images', async (req, res) => {
  try {
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();

    const { id, variantId } = req.params;
    const { imageUrl, description } = req.body;

    console.log(`ğŸ“¸ [VARIANT-IMAGE-ADD] Adding image to variant ${variantId}:`, imageUrl);

    if (!imageUrl) {
      return res.status(400).json({
        success: false,
        error: 'Image URL is required',
        message: 'Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨'
      });
    }

    // Validate URL format
    try {
      new URL(imageUrl);
    } catch (error) {
      return res.status(400).json({
        success: false,
        error: 'Invalid URL format',
        message: 'Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© ØºÙŠØ± ØµØ­ÙŠØ­'
      });
    }

    // Get current variant
    const variant = await prisma.productVariant.findUnique({
      where: { id: variantId },
      include: { product: true }
    });

    if (!variant || variant.productId !== id) {
      return res.status(404).json({
        success: false,
        error: 'Variant not found',
        message: 'Ø§Ù„Ù…ØªØºÙŠØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
      });
    }

    // Parse existing images
    let currentImages = [];
    try {
      currentImages = variant.images ? JSON.parse(variant.images) : [];
    } catch (error) {
      console.log('âš ï¸ [VARIANT-IMAGE-ADD] Error parsing existing images, starting fresh');
      currentImages = [];
    }

    // Check if image already exists
    if (currentImages.includes(imageUrl)) {
      return res.status(400).json({
        success: false,
        error: 'Image already exists',
        message: 'Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„'
      });
    }

    // Add new image
    currentImages.push(imageUrl);

    // Update variant
    const updatedVariant = await prisma.productVariant.update({
      where: { id: variantId },
      data: {
        images: JSON.stringify(currentImages)
      }
    });

    console.log(`âœ… [VARIANT-IMAGE-ADD] Image added successfully. Total images: ${currentImages.length}`);

    await prisma.$disconnect();

    res.json({
      success: true,
      data: {
        productId: id,
        variantId,
        imageUrl,
        totalImages: currentImages.length,
        allImages: currentImages
      },
      message: 'ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ù…ØªØºÙŠØ± Ø¨Ù†Ø¬Ø§Ø­'
    });

  } catch (error) {
    console.error('âŒ [VARIANT-IMAGE-ADD] Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to add image to variant',
      message: 'ÙØ´Ù„ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ù…ØªØºÙŠØ±',
      details: error.message
    });
  }
});

// Delete image from product endpoint
router.delete('/:id/images', async (req, res) => {
  try {
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();

    const { id } = req.params;
    const { imageUrl } = req.body;

    console.log(`ğŸ—‘ï¸ [IMAGE-DELETE] Removing image from product ${id}:`, imageUrl);

    if (!imageUrl) {
      console.log('âŒ [IMAGE-DELETE] Error: Image URL is required');
      return res.status(400).json({
        success: false,
        error: 'Image URL is required',
        message: 'Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨'
      });
    }

    // Get current product
    const product = await prisma.product.findUnique({
      where: { id: id }
    });

    if (!product) {
      console.log(`âŒ [IMAGE-DELETE] Error: Product ${id} not found`);
      await prisma.$disconnect();
      return res.status(404).json({
        success: false,
        error: 'Product not found',
        message: 'Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
      });
    }

    console.log(`ğŸ“¦ [IMAGE-DELETE] Current product images:`, product.images);

    // Parse existing images
    let currentImages = [];
    try {
      currentImages = product.images ? JSON.parse(product.images) : [];
      console.log(`ğŸ“‹ [IMAGE-DELETE] Parsed current images:`, currentImages);
    } catch (parseError) {
      console.log('âš ï¸ [IMAGE-DELETE] Warning: Could not parse existing images');
      currentImages = [];
    }

    // Remove image URL
    const initialCount = currentImages.length;
    currentImages = currentImages.filter(img => img !== imageUrl);
    const finalCount = currentImages.length;

    if (initialCount === finalCount) {
      console.log(`â„¹ï¸ [IMAGE-DELETE] Image URL not found in product images`);
      await prisma.$disconnect();
      return res.status(404).json({
        success: false,
        error: 'Image not found',
        message: 'Ø§Ù„ØµÙˆØ±Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'
      });
    }

    console.log(`â– [IMAGE-DELETE] Removed image. Images count: ${initialCount} â†’ ${finalCount}`);

    // Update product in database
    const updatedProduct = await prisma.product.update({
      where: { id: id },
      data: {
        images: JSON.stringify(currentImages)
      }
    });

    console.log(`âœ… [IMAGE-DELETE] Successfully removed image from product ${id}`);
    console.log(`ğŸ“Š [IMAGE-DELETE] Final images array:`, currentImages);

    await prisma.$disconnect();

    // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ Ø­Ø°Ù ØµÙˆØ±Ø©
    try {
      const ragService = require('../services/ragService');
      await ragService.updateKnowledgeBase();
      console.log('âœ… RAG Knowledge Base updated after image deletion');
    } catch (ragError) {
      console.error('âš ï¸ Failed to update RAG after image deletion:', ragError.message);
      // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
    }

    res.json({
      success: true,
      message: 'ØªÙ… Ø­Ø°Ù Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­',
      data: {
        removedImageUrl: imageUrl,
        productId: id,
        remainingImages: currentImages.length,
        allImages: currentImages
      }
    });

  } catch (error) {
    console.error('âŒ [IMAGE-DELETE] Error removing image:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…'
    });
  }
});

// Image upload from URL endpoint
router.post('/:id/images/url', async (req, res) => {
  try {
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();

    const { id } = req.params;
    const { imageUrl } = req.body;

    console.log(`ğŸ–¼ï¸ [IMAGE-URL] Adding image URL to product ${id}:`, imageUrl);

    if (!imageUrl) {
      console.log('âŒ [IMAGE-URL] Error: Image URL is required');
      return res.status(400).json({
        success: false,
        error: 'Image URL is required',
        message: 'Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨'
      });
    }

    // Validate URL format
    try {
      new URL(imageUrl);
      console.log('âœ… [IMAGE-URL] URL format is valid');
    } catch {
      console.log('âŒ [IMAGE-URL] Error: Invalid URL format');
      return res.status(400).json({
        success: false,
        error: 'Invalid URL format',
        message: 'ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­'
      });
    }

    // Get current product
    const product = await prisma.product.findUnique({
      where: { id: id }
    });

    if (!product) {
      console.log(`âŒ [IMAGE-URL] Error: Product ${id} not found`);
      await prisma.$disconnect();
      return res.status(404).json({
        success: false,
        error: 'Product not found',
        message: 'Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
      });
    }

    console.log(`ğŸ“¦ [IMAGE-URL] Current product images:`, product.images);

    // Parse existing images
    let currentImages = [];
    try {
      currentImages = product.images ? JSON.parse(product.images) : [];
      console.log(`ğŸ“‹ [IMAGE-URL] Parsed current images:`, currentImages);
    } catch (parseError) {
      console.log('âš ï¸ [IMAGE-URL] Warning: Could not parse existing images, starting fresh');
      currentImages = [];
    }

    // Add new image URL
    if (!currentImages.includes(imageUrl)) {
      currentImages.push(imageUrl);
      console.log(`â• [IMAGE-URL] Added new image URL. Total images: ${currentImages.length}`);
    } else {
      console.log(`â„¹ï¸ [IMAGE-URL] Image URL already exists, skipping duplicate`);
    }

    // Update product in database
    const updatedProduct = await prisma.product.update({
      where: { id: id },
      data: {
        images: JSON.stringify(currentImages)
      }
    });

    console.log(`âœ… [IMAGE-URL] Successfully updated product ${id} with new images`);
    console.log(`ğŸ“Š [IMAGE-URL] Final images array:`, currentImages);

    await prisma.$disconnect();

    // ØªØ­Ø¯ÙŠØ« RAG Knowledge Base Ø¨Ø¹Ø¯ Ø¥Ø¶Ø§ÙØ© ØµÙˆØ±Ø© Ù…Ù† URL
    try {
      const ragService = require('../services/ragService');
      await ragService.updateKnowledgeBase();
      console.log('âœ… RAG Knowledge Base updated after image URL addition');
    } catch (ragError) {
      console.error('âš ï¸ Failed to update RAG after image URL addition:', ragError.message);
      // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« RAG
    }

    res.json({
      success: true,
      message: 'ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­',
      data: {
        imageUrl: imageUrl,
        productId: id,
        totalImages: currentImages.length,
        allImages: currentImages
      }
    });

  } catch (error) {
    console.error('âŒ [IMAGE-URL] Error adding image from URL:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…'
    });
  }
});

// Public product details route (no authentication required)
router.get('/:id', productController.getProduct);

// Authenticated routes
router.use(mockAuth);

// Routes that require authentication - specific routes before generic
router.patch('/:id', productController.updateProduct);
router.delete('/:id', productController.deleteProduct);

module.exports = router;
